<!--
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
-->

<!--
`<line-chart>` is used to display a line chart updating in real-time to the user
in an efficient way and without locking the js thread for too long.

It is not a very advanced and pretty line chart render, but it is very specialized
for the testrtc use case where delaying the JS thread incurs delays on measuring
the round-trip time.
-->
<link rel="import" href="../../polymer/polymer.html">
<polymer-element name="line-chart">
  <template>
    <canvas id="canvas" width="300" height="150"></canvas>
  </template>
  <script>
    var interval = 0;
    Polymer({
      x: [],
      y: [],
      yScale: [0, 1000],
      yLabels: [0, 50, 100, 200, 500],
      xStart: null,
      addDatapoint: function (timestamp, value) {
        var start = window.performance.now();
        this.ctx = this.$.canvas.getContext('2d');

        var index = this.x.length;
        this.x.push(timestamp / 100.0 * 2);
        this.y.push(this.calculateY(value));

        if (this.xStart === null || this.x[index] - this.xStart > this.$.canvas.width) {
          // First point added or a point added that clears the chart.
          this.xStart = this.x[index];
          this.setupChart();
        } else {
          this.ctx.strokeStyle = (Math.min(this.y[index], this.y[index-1]) < 50 ? 'red': 'green');
          this.ctx.beginPath();
          this.ctx.moveTo(this.x[index - 1] - this.xStart, this.y[index - 1]);
          this.ctx.lineTo(this.x[index] - this.xStart, this.y[index]);
          this.ctx.stroke();
          this.ctx.closePath();
        }
        interval = window.performance.now() - start;
        console.log(interval);
      },

      setupChart: function () {
        this.ctx.clearRect (0 , 0, this.$.canvas.width, this.$.canvas.height);
        this.ctx.save();
        this.ctx.lineWidth = window.devicePixelRatio;
        this.ctx.strokeStyle = 'gray';
          if (this.ctx.lineWidth % 2)
            this.ctx.translate(0.5, 0.5);

          this.ctx.beginPath();
          this.ctx.moveTo(0, this.$.canvas.height);
          this.ctx.lineTo(0, 0);
          this.ctx.moveTo(0, this.$.canvas.height);
          this.ctx.lineTo(this.$.canvas.width, this.$.canvas.height);
          this.ctx.moveTo(0, 100);
          for (var index = 0; index != this.yLabels.length; index++) {
            var y = this.calculateY(this.yLabels[index]);
            this.ctx.fillText(this.yLabels[index] + ' ms', 0, y - 2);
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.$.canvas.width, y);
          }
          this.ctx.stroke();
          this.ctx.closePath();
        this.ctx.restore();

        this.ctx.lineWidth = window.devicePixelRatio * 2;
      },

      calculateY: function (value) {
        if (value > this.yScale[1]) { value = this.yScale[1] - 10; }
        var y = (value - this.yScale[0])/(this.yScale[1] - this.yScale[0]);
        return this.$.canvas.height * (1 - y) - 1;
      }
    });
  </script>
</polymer-element>
